#!/usr/bin/env python3

#
# Usage notes:
#
# Before running the script,
# 1. Export environment variables that are used by KiCAD
#    e.g. export KICAD8_3DMODEL_DIR=/usr/share/kicad/3dmodels
# 2. Ensure runtime dependencies are met.  Meshlab and
#    KiCAD are used for file format conversion at this time.
#    Without them, the script will fail
#

# Standard imports
import argparse
import os
import functools
from pprint import pprint
import numpy as np
import sys
import json
import subprocess
import tempfile
import re
import copy
import math

# Local imports
from jigcommon import *
import edge_cuts
import mesh_ops
import jigconfig
import tripy
import gen_scad

# These are all modules you need to have
try:
    import tinyobjloader
    import pcbnew
    import solid2
    import toml
    import shapely
except ImportError as err:
    print(f'Missing module : {err.name}', file=sys.stderr)
    print('Please install it using pip, and retry.')
    sys.exit(1)

import scipy.spatial
from scipy.spatial.transform import Rotation
import toml
from shapely.geometry import Polygon


def get_courtyard_polygon(shape):
    # Courtyard Polygon Coordinate System Note:
    #
    # KiCAD returned courtyard polygons are in the KiCAD coordinate system. No need to apply
    # offset or rotation. Just negate Y

    # Shree : Grr.. how do I extract the freakin points.
    # No API for get polygon ? Looks like only set stuff works from Python,
    # but gets are only in C. Find this hard to believe...
    # FIXME find out what you don't know!
    #shape.Format(False) gives a C/C++ source code representation !!
    #---------
    #SHAPE_LINE_CHAIN poly;
    #auto tmp = SHAPE_LINE_CHAIN( { VECTOR2I( 215000000, 105500000), VECTOR2I( 246000000, 88000000), VECTOR2I( 260500000, 118500000)}, true );;
    #poly.AddOutline(tmp); }
    #---------
    shapeText = shape.Format(False)
    verts = []
    for s_pt in re.findall('VECTOR2I\\( [0-9]+, [0-9]+\\)',shapeText):
        coord_parts = s_pt.split(' ')[1:]
        x = units_to_mm(int(coord_parts[0][:-1]))
        y = -units_to_mm(int(coord_parts[1][:-1]))
        verts.append([x,y]) # YES, and yikes!
    return verts

def get_ref_info(board):
    mounting_holes = []
    fp_list = board.Footprints()
    ref_map = {}
    fp_map = {}
    for fp in fp_list:
        ref = fp.GetReference()
        fp_x = units_to_mm(fp.GetX())
        fp_y = -units_to_mm(fp.GetY())
        #print(fp.GetReference())
        #print('  Position(mm):', fp_x, fp_y)
        #print('  On side     :', fp.GetSide())
        #print('  Orientation :', fp.GetOrientation().AsDegrees())
        #print('  DNP ?       :', fp.IsDNP())
        #print('  TH ?        :', fp.HasThroughHolePads())
        models_3d = []
        for mod3d in fp.Models():
            # NOTE XXX don't hold references to internal vectors - they can get
            # messed up! Make copies!
            models_3d.append({
                'model'    : mod3d.m_Filename,
                'offset'   : [mod3d.m_Offset[0], mod3d.m_Offset[1], mod3d.m_Offset[2]],
                'scale'    : [mod3d.m_Scale[0], mod3d.m_Scale[1], mod3d.m_Scale[2]],
                'rotation' : [mod3d.m_Rotation[0], mod3d.m_Rotation[1], mod3d.m_Rotation[2]]
            })
        fp_rot = fp.GetOrientation().AsDegrees()
        fields = fp.Fields()
        footprint = fields[2].GetText() # e.g. Package_QFP:LQFP-128_14x14mm_P0.4mm
        ref_info = {
            'is_th' : fp.HasThroughHolePads(),
            'footprint' : footprint,
            'x' : fp_x,
            'y' : fp_y,
            'orientation' : fp_rot,
            'side' : fp.GetSide(),
            'position' : fp.GetPosition(),
            'models' : models_3d,
            'kfp' : fp, # Reference if we need more info later
            'front_courtyard' : get_courtyard_polygon(fp.GetCourtyard(pcbnew.F_CrtYd)),
            'back_courtyard' : get_courtyard_polygon(fp.GetCourtyard(pcbnew.B_CrtYd)),
        }

        is_mounting_hole = False
        if fp.HasThroughHolePads():
            for fn in fp.Fields():
                if fn.GetText().startswith('MountingHole'):
                    mounting_holes.append(
                        [fp_x, fp_y]
                    )
                    is_mounting_hole = True
                    break
        ref_map[ref] = ref_info

        # remember that this footprint has this ref
        if not is_mounting_hole:
            if footprint in fp_map:
                fp_map[footprint]['refs'].append(ref)
            else:
                fp_map[footprint] = {
                    'is_th' : fp.HasThroughHolePads(),
                    'refs' : [ref],
                    'alias' : None,
                    'display_name' : None,
                    'force_smd' : False
                }


        #print(fp.Footprint().GetName())
        #pprint(dir(fp.Footprint()))
    return ref_map, fp_map, mounting_holes

def load_3d_models(ref_list, ref_map, desc):
    temp_dir = os.path.expanduser(os.environ['TMPDIR']) if 'TMPDIR' in os.environ else None
    scriptdir = os.path.dirname(os.path.realpath(__file__))
    fnames = []
    for ref in ref_list:
        comp = ref_map[ref]
        for modinfo in comp['models']:
            model_filename = os.path.expandvars(modinfo['model'])
            fnames.append(model_filename)
    # get uniques
    fnames = list(set(fnames))
    print(f'Loading {len(fnames)} 3D models for {desc} components...')
    for ref in ref_list:
        comp = ref_map[ref]
        for modinfo in comp['models']:
            model_filename = os.path.expandvars(modinfo['model'])
            modinfo['mesh'] = mesh_ops.load_mesh(model_filename, scriptdir, temp_dir)

def expand_small_hole(poly_verts, area=None):
    if area is None:
        tris = tripy.earclip(poly_verts)
        area = tripy.calculate_total_area(tris)
    printable_threshold = cfg['3dprinter']['min_printable_hole_area']
    if area < printable_threshold:
        spoly = Polygon(poly_verts)
        # search in 0.01 mm offset increments
        # this helps achieve a good fit with the minimum
        # Note here we are not considering the gap that will be applied
        # additionally while generating the shell, so we are guaranteed to
        # be always higher than the safe limit
        search_steps = 10
        for offset in range(search_steps):
            offset_val = (offset+1)/search_steps
            offset_poly = spoly.buffer(offset_val)
            if offset_poly.area >= printable_threshold:
                print(f'  offset = {offset_val} improved area to {offset_poly.area} from {spoly.area}')
                poly_verts = offset_poly.exterior.coords
                break
    return poly_verts

def gen_fitting_pockets(mesh, z_bin_size):
    all_z = np.unique(mesh[:,2])
    all_z.sort()
    # we start working from highest Z (farthest from board)
    # and compute the "step-wells", i.e. convex hulls
    reverse_z = all_z[::-1]

    z_bins = []
    z_bins.append({
        "start_z" : reverse_z[0],
        "z_list" : [],
        "verts" : None
    })

    for z_val in reverse_z:
        # find all the verts at this Z
        mask = np.isin(element = mesh[:,2], test_elements=z_val)
        result = mesh[mask]

        # append to existing bin, if we belong to the same bin,
        # else start a new bin
        last_z_bin = z_bins[-1]["start_z"]
        if last_z_bin-z_val < z_bin_size:
            if z_bins[-1]["verts"] is None:
                z_bins[-1]["verts"] = result
            else:
                z_bins[-1]["verts"] = np.concatenate([z_bins[-1]["verts"], result])
            z_bins[-1]["z_list"].append(z_val)
        else:
            z_bins.append({
                "start_z" : z_val,
                "z_list" : [z_val],
                "verts" : result
            })

    # Each bin basically represents an area that casts a shadow looking down at Z=0
    # We can take the convex hull of the area.
    # Subsequent bins will keep adding to convex hulls from the previous bins
    # Thus, cumulatively we'll cover every bin, and the largest covex hull will be
    # at the bottom, allowing the part to slide in.

    prev_bin = None
    hull_bins = []
    for this_bin in z_bins:
        points_xy = this_bin['verts'][:,0:2] # chuck Z
        if len(hull_bins)>0:
            points_xy = np.concatenate([points_xy, hull_bins[-1]['hull']])
        hull = scipy.spatial.ConvexHull(points_xy)
        hull_verts = points_xy[hull.vertices]
        tris = tripy.earclip(hull_verts)
        area = tripy.calculate_total_area(tris)

        hull_verts = expand_small_hole(hull_verts, area)
        if len(hull_bins)>0:
            if area > hull_bins[-1]['area']+1: # heh - looking for some meaningful change :)
                # start new bin
                hull_bins.append({
                    'hull' : hull_verts,
                    'area' : area,
                    'z_list' : this_bin['z_list']
                })
            else:
                hull_bins[-1]['z_list'] = hull_bins[-1]['z_list']+this_bin['z_list']
        else:
            hull_bins.append({
                'hull' : hull_verts,
                'area' : area,
                "z_list" : this_bin["z_list"],
            })

    # reverse the hull bins, as it represents the right order of
    # cutting out!
    hull_bins.reverse()

    for idx, h_bin in enumerate(hull_bins):
        h_bin['z_list'].sort()
        if idx==0:
            h_bin['start_z'] = h_bin['z_list'][0]
        else:
            h_bin['start_z'] = hull_bins[idx-1]['z_list'][-1]
        h_bin['end_z'] = h_bin['z_list'][-1]

    # Each bin has start_z, end_z, area, hull and z_list keys
    return hull_bins

def veclen(p):
    return math.sqrt(p[0]*p[0]+p[1]*p[1])

def line2vec(p1, p2):
    return [p2[0]-p1[0], p2[1]-p1[1]]

def angle2lines(p1,p2,p3): # (p2,p1) and (p2,p3)
    #print('points = ', p1,p2,p3)
    vec1 = line2vec(p2, p1)
    l1 = veclen(vec1)
    if l1==0.0:
        return 180
    vec2 = line2vec(p2, p3)
    l2 = veclen(vec2)
    if l2==0.0:
        return 180
    vec1 = [v/l1 for v in vec1]
    vec2 = [v/l2 for v in vec2]
    dotproduct = vec1[0]*vec2[0]+vec1[1]*vec2[1]
    return math.acos(dotproduct)*180/math.pi

def extract_corners_2D(poly_points, angular_thresh=10.0):
    """ Input is a 2D polygon. This function extracts "corners"
        in the polygon.  A corner is basically where two consective
        line segments have an angle more than the specified threshold """
    #print('  extract_corners_2D')
    xy = [ [pt[0], pt[1]] for pt in poly_points ]
    pt0 = xy[0]
    ptN = xy[-1]
    # NOTE: sometimes last point and first are same ! In that
    # case no need to replicate start and end points
    if not (pt0[0] == ptN[0] and pt0[1] == ptN[1]):
        #print('    extend both sides')
        xy.insert(0,ptN)
        xy.append(pt0)
    #print('    xy=',xy)
    angles = []
    result = []
    # we iterate and get angles between every two consecutive line
    # segments in the polygon (including the first and the last)
    # Any angle not close to 180 by angular_thresh is a corner.
    for idx in range(1,len(xy)-1):
        # FIXME : probably not the best performing code. Do some
        # numpy magic ?
        this_angle = angle2lines(xy[idx-1], xy[idx], xy[idx+1])
        angles.append(this_angle)
        if this_angle < (180-angular_thresh):
            result.append(copy.copy(xy[idx]))
    #print('    angles=',angles)
    #print('    corners=', len(result), ' which are', result)
    return result

#
# Execution starts here
#
parser = argparse.ArgumentParser(
    description='Create jigs in a jiffy',
    epilog='Use the examples, Luke!')

group = parser.add_mutually_exclusive_group()
group.add_argument('--examples', default=False, action='store_true',
    help='''Shows examples of usage''')
group.add_argument('-i','--pcb', metavar='FILENAME',
    help='KiCAD PCB file (.kicad_pcb) to process')
group.add_argument('--footprint', metavar='SPEC',
    action='extend', nargs='+', type=str,
    help='''Generate a shell for specified kicad library footprint(s),
instead of a PCB. Use --examples for info on SPEC''')
group.add_argument('--model3d', action='extend', nargs='+', type=str,
    help='''Generate a shell from 3D model(s).''')

parser.add_argument('--config', metavar='FILENAME.toml',
    help='Use this configuration options file for various parameters.')

parser.add_argument('--pcb-footprints', type=bool, default=False,
    help='''Generates one shell per footprint used on the PCB design.''')
parser.add_argument('-o','--output',
    help='Output file.')
parser.add_argument('-f', '--output-format', choices=['stl','scad'],
    help='Output file format. Default autodect based on output file extension.')
parser.add_argument('--keep-orientation',
    action='store_true',
    default=False,
    help='''Match orientation of the output to KiCAD 3D view.
The default orients the output for direct printing (i.e. rotated by 180 degrees
along the X axis.)''')
parser.add_argument('--dump-config', metavar='FILENAME.toml',
    help='''Save a copy of the effective configuration after applying
    internal defaults, user and config file.''')
parser.add_argument('--genconfig', metavar='FILENAME.toml',
    help='''Generate a default configuration file, from an
    input KiCAD PCB. This lists all footprint and components.
    User friendly openscad output can be generated, starting
    with that as the base''')

group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", help='Verbose messages')
group.add_argument("-q", "--quiet", help='Info messages are suppressed')
args = parser.parse_args()

if args.examples:
    print(f"Sorry, examples aren't created yet. Use the source, Luke!", file=sys.stderr)
    sys.exit(1)
if args.footprint:
    print(f"Sorry, the footprint option isn't implemented yet", file=sys.stderr)
    sys.exit(1)

if args.model3d:
    print(f"Sorry, the model3d option isn't implemented yet", file=sys.stderr)
    sys.exit(1)

if not args.pcb:
    print(f'ERROR: Need a KiCAD PCB to work on. Use -h or --examples for more help', file=sys.stderr)
    sys.exit(1)

# determine extension
if not args.output_format:
    out_split = os.path.splitext(args.output)
    out_ext = out_split[1] # will be empty string if no extension
    if out_ext in ['.stl','.scad']:
        args.output_format = out_ext[1:]
    if not args.output_format:
        print(f"Unrecorgnized extension in output filename '{args.output}'", file=sys.stderr)
        sys.exit(1)

board = pcbnew.LoadBoard(args.pcb)
#smd_info, th_info, mounting_holes = get_ref_info(board)
ref_map, fp_map, mounting_holes = get_ref_info(board)

if args.genconfig:
    jigconfig.generate_config(args.genconfig, ref_map, fp_map)
    sys.exit(0)

jigconfig.load_user_config('jigify')

try:
    cfg, config_text, used_th_fp, th_ref_list, smd_ref_list = jigconfig.load(args.config, ref_map, fp_map)
except ValueError as err:
    print(f"ERROR: {err}", file=sys.stderr)
    sys.exit(-1)
#pprint(cfg)

if args.dump_config:
    with open(args.dump_config, 'w') as fp:
        toml.dump(cfg, fp)

if not args.output:
    print(f"ERROR: Need an output file", file=sys.stderr)
    sys.exit(-1)

pcb_thickness = cfg['pcb']['thickness']
shell_clearance = cfg['TH']['component_shell']['shell_clearance_from_pcb']
shell_type = cfg['TH']['component_shell']['shell_type']
if shell_type in ['tight']:
    print(f"ERROR: shell_type='{shell_type}' is not implemented yet.", file=sys.stderr)
    sys.exit(-1)
shell_gap = cfg['TH']['component_shell']['shell_gap']
shell_thickness = cfg['TH']['component_shell']['shell_thickness']

arc_resolution = cfg['pcb']['tesellate_edge_cuts_curve']

base_line_width = cfg['holder']['base']['line_width']
base_line_height = cfg['holder']['base']['line_height']
pcb_perimeter_height = cfg['holder']['base']['perimeter_height']
pcb_holder_gap = cfg['holder']['pcb_gap']
pcb_holder_overlap = cfg['holder']['pcb_overlap']
pcb_holder_perimeter = cfg['holder']['perimeter']
forced_pcb_supports = cfg['holder']['forced_grooves']
groove_size = cfg['holder']['groove_size']
ref_do_not_process = cfg['TH']['refs_do_not_process']
ref_process_only_these = cfg['TH']['refs_process_only_these']
jig_type = cfg['jig']['type']
jig_type_component_fitting = (jig_type == 'component_fitting')
smd_clearance_from_shells = cfg['SMD']['clearance_from_shells']
smd_gap_from_shells = cfg['SMD']['gap_from_shells']
if jig_type_component_fitting:
    if shell_clearance>0:
        print('INFO: Generating component shells, note shell_clearance=%s will cut into shell.'
            %(shell_clearance))

mounting_holes += forced_pcb_supports

# Setup environment for file name expansion
# First take from user config
for env_var_name in cfg['environment']:
    os.environ[env_var_name] = cfg['environment'][env_var_name]
os.environ["KIPRJMOD"] = os.path.split(args.pcb)[0]
# Now add onto it, this allows overrides from user config
path_sys_3dmodels = '/usr/share/kicad/3dmodels'
for ver in ['', 6,7,8]: # Hmm - would we need more ?
    env_var_name = 'KICAD%s_3DMODEL_DIR'%(ver)
    if env_var_name not in os.environ:
        os.environ[env_var_name] = path_sys_3dmodels

load_3d_models(th_ref_list, ref_map, 'Through Hole')
load_3d_models(smd_ref_list, ref_map, 'SMD')

if args.output_format == 'stl':
    fp_scad = tempfile.NamedTemporaryFile(mode='w', suffix='.scad', delete_on_close=False)
    oscad_filename = fp_scad.name
    stl_filename = args.output
else:
    oscad_filename = args.output
    fp_scad = open(oscad_filename, 'w')

pcb_segments = []
pcb_filled_shapes = []
seg_shapes = []

edge_cuts.load(board, pcb_segments, pcb_filled_shapes)

seg_shapes = []
if not edge_cuts.coalesce_segments(pcb_segments, seg_shapes):
    print('ERROR: Please check the edge cuts layer in KiCAD.')
    print('ERROR: There are incomplete outlines. DRC or 3D View should help')
    print('ERROR: diagnose the issue')
    sys.exit(-1)

edge_cuts.tesellate(arc_resolution, seg_shapes, pcb_filled_shapes)
edge_cuts.compute_areas(pcb_filled_shapes)

if len(pcb_filled_shapes) == 0:
    print('ERROR: At-least one filled shape is needed in Edge.Cuts layer')
    print('Please check and validate board file.')
    sys.exit(-1)

# Find the largest filled area. This is assumed to be the actual
# PCB outline
pcb_filled_shapes.sort(key=lambda x:x['area'], reverse=True)
# And hence these are the vertices
pcb_edge_points = pcb_filled_shapes[0]['vertices']

def xform_mesh(mesh, modinfo, orientation):
    mesh_scale = mesh * modinfo['scale']
    # FIXME: Hrrmph! why should I need to reverse these
    # angles !?
    rx = Rotation.from_euler('x', -modinfo['rotation'][0], degrees=True)
    ry = Rotation.from_euler('y', -modinfo['rotation'][1], degrees=True)
    rz = Rotation.from_euler('z', -modinfo['rotation'][2], degrees=True)
    rot_angle=th['orientation'];
    rz2 = Rotation.from_euler('z', rot_angle, degrees=True)
    r_xyz = rx*ry*rz
    mesh_rotated = r_xyz.apply(mesh_scale)
    mesh2 = mesh_rotated + [modinfo['offset'][0], modinfo['offset'][1], modinfo['offset'][2]]
    mesh = rz2.apply(mesh2)
    min_z = min(mesh[:,2])
    max_z = max(mesh[:,2])
    return mesh, min_z, max_z

all_shells = []
fp_centers = []
topmost_z = 0

# For each TH component on the board
for this_ref in th_ref_list:
    print('Processing TH :', this_ref)
    # each footprint can have multiple models.
    # each model that is "in contact" with the board will generate
    # a shell
    local_max_z = 0
    local_min_z = float('inf')
    subshells = {
        'ref' : this_ref,
        'wiggle' : [],
        'courtyard' : None
    }
    th = ref_map[this_ref]
    for idx, modinfo in enumerate(th['models']):
        mesh = modinfo['mesh']
        if mesh.shape[0]==0:
            print('  WARNING: Mesh %s is empty on import. Watch out for intended side effects. SKIPPING!'
                  %(modinfo['model']))
            continue
        mesh, min_z, max_z = xform_mesh(mesh, modinfo, th['orientation'])
        #print('min_z = ', min_z, ' max_z = ', max_z)
        if min_z>0:
            print('  Mesh %s is NOT mounted on board. Skipping.'%(modinfo['model']))
        else:
            min_x = min(mesh[:,0])
            max_x = max(mesh[:,0])
            min_y = min(mesh[:,1])
            max_y = max(mesh[:,1])
            center_x = ((min_x + max_x)/2)
            center_y = ((min_y + max_y)/2)
            fp_centers.append([center_x+th['x'],center_y+th['y']])
            #print('Hull size = ', len(hull.vertices), ' min Z=', min_z, ' max Z=', max_z)
            #print(hull_verts)
            shell_ident = '%s_%d'%(this_ref,idx)
            h_bins = gen_fitting_pockets(mesh, 0.5)
            for this_bin in h_bins:
                this_bin['corners'] = extract_corners_2D(this_bin['hull'])

            subshells['wiggle'].append({
                'name':shell_ident,
                'min_z':min_z,
                'max_z':max_z,
                'model':modinfo['model'],
                'x' : th['x'],
                'y' : th['y'],
                'orientation' : th['orientation'],
                'mesh' : mesh,
                'fp_center': [center_x+th['x'],center_y+th['y']],
                'fitting_bins' : h_bins
            })
            print('  Generating shell %s for ref %s with mesh %s'%(shell_ident, this_ref, modinfo['model']))
            local_max_z = max(local_max_z, max_z)
            local_min_z = min(local_min_z, min_z)
    if local_max_z > 0: # Means we found a mesh
        subshells['max_z'] = local_max_z
        subshells['min_z'] = local_min_z
        subshells['front_courtyard'] = th['front_courtyard']
        all_shells.append(subshells)
    topmost_z = max(topmost_z, local_max_z)

smd_keepouts = []
for this_ref in smd_ref_list:
    smd = ref_map[this_ref]
    #print('Processing SMD :', smd['ref'])
    # each footprint can have multiple models.
    # each model that is "in contact" with the board will generate
    # a shell
    for idx, modinfo in enumerate(smd['models']):
        mesh = modinfo['mesh']
        if mesh.shape[0]==0:
            print('  WARNING: Mesh %s is empty on import. Watch out for intended side effects. SKIPPING!'
                  %(modinfo['model']))
            continue
        mesh, min_z, max_z = xform_mesh(mesh, modinfo, smd['orientation'])
        keepout_ident = '%s_%d'%(this_ref,idx)
        smd_keepouts.append({
            'name' : keepout_ident,
            'ref' : this_ref,
            'min_z':min_z,
            'max_z':max_z,
            'model':modinfo['model'],
            'x' : smd['x'],
            'y' : smd['y'],
            'orientation' : smd['orientation'],
            'front_courtyard' : smd['front_courtyard']
        })
        topmost_z = max(topmost_z, max_z)

# Compute bounding box of PCB
# FIXME: make this min, max code less verbose
pcb_min_x = pcb_max_x = pcb_edge_points[0][0]
pcb_min_y = pcb_max_y = pcb_edge_points[0][1]
for pt in pcb_edge_points:
    pcb_min_x = min(pcb_min_x, pt[0])
    pcb_max_x = max(pcb_max_x, pt[0])
    pcb_min_y = min(pcb_min_y, pt[1])
    pcb_max_y = max(pcb_max_y, pt[1])

pcb_bb_corners = [
    [pcb_min_x , pcb_min_y],
    [pcb_min_x , pcb_max_y],
    [pcb_max_x , pcb_min_y],
    [pcb_max_x , pcb_max_y]
]

# Delaunay triangulation will be done on the following points
# 1. centers of all considered footprints
# 2. mounting holes
# 3. bounding box corners of PCB edge. mounting holes are
#    inside the PCB and don't extend all the way to the edge.
#    If we don't include them, we may end up having a separate
#    "delaunay island", depending on the exact PCB.
dt_centers = fp_centers + mounting_holes + pcb_bb_corners

mesh_line_segments = []
if len(dt_centers)>=4:
    mesh_comment = 'delaunay triangulated mesh'
    d_verts = np.array(dt_centers)
    d_tris = scipy.spatial.Delaunay(d_verts)
    for tri in d_tris.simplices:
        # tri is a,b,c
        av = d_verts[tri[0]]
        a = [av[0], av[1]]
        bv = d_verts[tri[1]]
        b = [bv[0], bv[1]]
        cv = d_verts[tri[2]]
        c = [cv[0], cv[1]]
        mesh_line_segments.append([a,b])
        mesh_line_segments.append([b,c])
        mesh_line_segments.append([c,a])
else:
    if len(dt_centers)>1:
        av = dt_centers[0]
        a = [av[0],av[1]]
        bv = dt_centers[1]
        b = [bv[0],bv[1]]
        mesh_line_segments.append([a,b])
    if len(dt_centers)==3:
        cv = dt_centers[2]
        c = [cv[0],cv[1]]
        mesh_line_segments.append([b,c])
        mesh_line_segments.append([c,a])

groove_lines = edge_cuts.compute_grooves(arc_resolution, pcb_filled_shapes[0], groove_size)

gen_scad.generate_scad(
    fp_scad,
    config_text,
    cfg,
    args.pcb,
    args.config,
    args.keep_orientation,
    all_shells,
    fp_map,
    ref_map, smd_keepouts, topmost_z,
    pcb_edge_points,
    dt_centers,
    mesh_line_segments, groove_lines,
    pcb_min_x, pcb_max_x, pcb_min_y, pcb_max_y)

fp_scad.close()

if args.output_format == 'stl':
    cmd = []
    # FIXME - ideally we'll have a config in ~/.config to store things
    # like paths to binaries etc
    cfg_scad = cfg['openscad']
    cmd += [ os.path.expanduser(cfg_scad['binary']),
             '--hardwarnings' ]
    if cfg_scad['use_manifold']:
        cmd += [ '--backend', 'Manifold' ]
    cmd += [ '-o', stl_filename, oscad_filename ]
    print('Generating output using : %s'%(' '.join(cmd)))
    print('-----------------------------------------')
    retcode = subprocess.call(cmd)
    print('-----------------------------------------')
    if retcode !=0 :
        print('ERROR: OpenSCAD Failed, exit code %d'%(retcode))
    else:
        print('Done, output : %s'%(stl_filename))
else:
    print('Done, output : %s'%(oscad_filename))
#
#
# Coordinate system notes:
#
# We adhere to the normal 3D coordinate system in this program,
# with Z pointing up.
#
# KiCAD uses a coordinate system where X increases to the right,
# and Y increases down - like a regular framebuffer. Therefore,
# Y coordinates from KiCAD needs to be negated to map to the
# regular 3D system. Note that 3D meshes in KiCAD use the regular
# 3D coordinate system, so those coordinates don't need to be
# transformed.
#
# This script also uses OpenSCAD. The extrude operation extrudes
# along the positive Z axis - i.e. upwards.
#
# Z = 0 corresponds to the bottom of the PCB. At the top of the
# PCB, Z = PCB thickness
#
# This setup is so that we can exactly match KiCAD's step file
# export of the board. Overlaying the mesh generated on this
# program on top of the step file is useful both for debugging
# as well as understanding any issues.
#
# Here is the Z coordinate stackup, for top side assembly.
# Soldering is on the bottom side.
#
# Z = topmost + 1 | "base". Start of 1 mm thick layer, delaunay triangles
#     +thickness  |
#
# Z = topmost     | topmost point of tallest component, when mounted on
#     +thickness | the PCB. Typically the long end of a berg header
#
# Z = in-between  | Highest point of intermediate height component
#
# Z = thickness+  | Start of typical shell
#     clearance   | Clearance allows user to visually verify component
#                 | placement and fit from the sides
#
# Z = thickness   | PCB top
#
# Z = 0           | PCB botto
#
# This program uses this terminology
#
# edge      => closed polygon matching exact border.
#              e.g. the outer edge of the PCB. In the case of a component
#              you can think of a projection of the 3d model of
#              the component onto the Z plane, and the resulting outline.
#              outlines can be concave.
#
# hull      => convex hull of the edge. Typically used as these are
#              easier to compute and have useful properties. Using
#              concave surfaces needs more care, else things may break.
#
# overlap   => small inset of the edge/hull.
#              offset value here is called "overlap" as well.
#
# outline    => small offset of the edge/hull (meaning outwards)
#               offset value here is called "gap"
#
# perimeter => large offset of the edge/hull. Typically used to
#              build "walls" or shells
#              offset value here is termed "thickness"
#
# component/board can slide inside outline, but will abut above an
# overlap. The term "clearance" is used to a gap in the
# Z direction.
#
# "pocket" is a negative shape - e.g. the hollow cavity required
# to push in a component
#
# "shell" is a solid shape with a cavity. the cavity is a "pocket" so
# that the component can be held in the pocket.
#
#
