#!/usr/bin/env python3

#
# Usage notes:
#
# Before running the script,
# 1. Export environment variables that are used by KiCAD
#    e.g. export KICAD8_3DMODEL_DIR=/usr/share/kicad/3dmodels
# 2. Ensure runtime dependencies are met.  Meshlab and
#    KiCAD are used for file format conversion at this time.
#    Without them, the script will fail
#

# Standard imports
import argparse
import os
import functools
from pprint import pprint
import numpy as np
import sys
import json
import subprocess
import tempfile
import re
import copy
import math
import pathlib

# Local imports
from jigcommon import *
import edge_cuts
import mesh_ops
import jigconfig
import tripy
import gen_scad
import compute_shells
import geom_ops

# These are all modules you need to have
try:
    import tinyobjloader
    import pcbnew
    import solid2
    import toml
    import shapely
except ImportError as err:
    print(f'Missing module : {err.name}', file=sys.stderr)
    print('Please install it using pip, and retry.')
    sys.exit(1)

import scipy.spatial
from scipy.spatial.transform import Rotation
import toml
from pcbnew import PCB_IO_MGR

def get_courtyard_polygon(shape):
    # Courtyard Polygon Coordinate System Note:
    #
    # KiCAD returned courtyard polygons are in the KiCAD coordinate system. No need to apply
    # offset or rotation. Just negate Y
    verts = []
    # FIXME: can we have more than one outline in the courtyard !?
    if shape.OutlineCount()>1:
        raise ValueError("ERROR: can't handle courtyards with more than 1 outlines", file=sys.stderr)

    for i in range(shape.OutlineCount()):
        lc = shape.Outline(i)
        for j in range(lc.PointCount()):
            pt = lc.CPoint(j)
            verts.append([pcbnew.ToMM(pt.x),-pcbnew.ToMM(pt.y)])
    return verts

def load_footprints(fp_spec_list):
    fp_map = {}
    ref_map = {}
    # FIXME: This idx business can cause obscure bugs with numbering from
    # jigconfig. Fix the right way!
    alias_idx = 1

    for this_spec in fp_spec_list:
        full_spec = this_spec
        if this_spec.find(':')==-1:
            full_spec += ':*'
        fp_lib, fp_name = full_spec.split(':')
        # if the lib name ends with pretty, it's a full filepath, including an
        # (optional) directory
        if not fp_lib.endswith('.pretty'):
            libpath = os.path.join('/usr/share/kicad/footprints',f"{fp_lib}.pretty")
            fp_lib_name = fp_lib
        else:
            dirname, fname = os.path.split(fp_lib[:-7]) # remove the .pretty
            fp_lib_name = fname
            libpath = fp_lib

        src_type = PCB_IO_MGR.GuessPluginTypeFromLibPath(libpath)
        plugin = PCB_IO_MGR.PluginFind(src_type)
        if not plugin:
            raise ValueError(f"No such footprint library: {libpath}")
        lib_fp_list = plugin.FootprintEnumerate(libpath)
        none_found = True
        for name in lib_fp_list:
            fp = plugin.FootprintLoad(libpath, name)
            if not pathlib.PurePath(name).match(fp_name):
                continue
            fp_complete_name = f"{fp_lib_name}:{name}"
            if not fp.HasThroughHolePads():
                print(f"WARNING: {fp_complete_name} is not a through hole component.")
                continue
            none_found = False
            this_alias = 'FP%d'%(alias_idx)
            models_3d = []
            for mod3d in fp.Models():
                models_3d.append({
                    'model'    : mod3d.m_Filename,
                    'offset'   : [mod3d.m_Offset[0], mod3d.m_Offset[1], mod3d.m_Offset[2]],
                    'scale'    : [mod3d.m_Scale[0], mod3d.m_Scale[1], mod3d.m_Scale[2]],
                    'rotation' : [mod3d.m_Rotation[0], mod3d.m_Rotation[1], mod3d.m_Rotation[2]]
                })
            fields = fp.Fields()
            footprint = fields[2].GetText() # e.g. Package_QFP:LQFP-128_14x14mm_P0.4mm
            ref_info = {
                'is_th' : fp.HasThroughHolePads(),
                'x': 0,
                'y': 0,
                'orientation' : 0,
                'footprint' : fp_complete_name,
                'side' : fp.GetSide(),
                'models' : models_3d,
                'kfp' : fp, # Reference if we need more info later
                'front_courtyard' : get_courtyard_polygon(fp.GetCourtyard(pcbnew.F_CrtYd)),
                'back_courtyard' : get_courtyard_polygon(fp.GetCourtyard(pcbnew.B_CrtYd)),
            }
            ref_map[this_alias] = ref_info
            fp_map[fp_complete_name] = {
                'is_th' : fp.HasThroughHolePads(),
                'refs' : [ ref_map[this_alias] ],
                'alias' : this_alias,
                'footprint' : fp,
                'display_name' : fp_complete_name,
                'force_smd' : False,
                'base_footprint' : fp
            }
            alias_idx += 1
        if none_found:
            raise ValueError(f"No usable matches for {this_spec}")

    return ref_map, fp_map

def xform_mesh(mesh, modinfo, orientation):
    mesh_scale = mesh * modinfo['scale']
    # FIXME: Hrrmph! why should I need to reverse these
    # angles !?
    rx = Rotation.from_euler('x', -modinfo['rotation'][0], degrees=True)
    ry = Rotation.from_euler('y', -modinfo['rotation'][1], degrees=True)
    rz = Rotation.from_euler('z', -modinfo['rotation'][2], degrees=True)
    rot_angle=th['orientation'];
    rz2 = Rotation.from_euler('z', rot_angle, degrees=True)
    r_xyz = rx*ry*rz
    mesh_rotated = r_xyz.apply(mesh_scale)
    mesh2 = mesh_rotated + [modinfo['offset'][0], modinfo['offset'][1], modinfo['offset'][2]]
    mesh = rz2.apply(mesh2)
    min_z = min(mesh[:,2])
    max_z = max(mesh[:,2])
    return mesh, min_z, max_z


def get_ref_info(fp_list, unity_xform):
    mounting_holes = {}
    ref_map = {}
    fp_map = {}
    for fp in fp_list:
        ref = fp.GetReference()
        fp_x = units_to_mm(fp.GetX())
        fp_y = -units_to_mm(fp.GetY())
        #print(fp.GetReference())
        #print('  Position(mm):', fp_x, fp_y)
        #print('  On side     :', fp.GetSide())
        #print('  Orientation :', fp.GetOrientation().AsDegrees())
        #print('  DNP ?       :', fp.IsDNP())
        #print('  TH ?        :', fp.HasThroughHolePads())
        models_3d = []
        for mod3d in fp.Models():
            # NOTE XXX don't hold references to internal vectors - they can get
            # messed up! Make copies!
            models_3d.append({
                'model'    : mod3d.m_Filename,
                'offset'   : [mod3d.m_Offset[0], mod3d.m_Offset[1], mod3d.m_Offset[2]],
                'scale'    : [mod3d.m_Scale[0], mod3d.m_Scale[1], mod3d.m_Scale[2]],
                'rotation' : [mod3d.m_Rotation[0], mod3d.m_Rotation[1], mod3d.m_Rotation[2]]
            })
        fp_rot = fp.GetOrientation().AsDegrees()
        fields = fp.Fields()
        footprint = fields[2].GetText() # e.g. Package_QFP:LQFP-128_14x14mm_P0.4mm
        ref_info = {
            'is_th' : fp.HasThroughHolePads(),
            'footprint' : footprint,
            'side' : fp.GetSide(),
            'position' : fp.GetPosition(),
            'models' : models_3d,
            'kfp' : fp, # Reference if we need more info later
            'front_courtyard' : get_courtyard_polygon(fp.GetCourtyard(pcbnew.F_CrtYd)),
            'back_courtyard' : get_courtyard_polygon(fp.GetCourtyard(pcbnew.B_CrtYd)),
        }
        ref_info['x'] = fp_x if not unity_xform else 0
        ref_info['y'] = fp_y if not unity_xform else 0
        ref_info['orientation'] = fp_rot if not unity_xform else 0

        is_mounting_hole = False
        if fp.HasThroughHolePads():
            could_be_mh = False
            for fn in fp.Fields():
                if fn.GetText().startswith('MountingHole'):
                    could_be_mh = True
                    break
            if could_be_mh:
                # mounting hole could have multiple pads - corresponding to copper, drill, etc
                for pad in fp.Pads():
                    ds = pad.GetDrillSize()
                    if ds[0]==0 or ds[1]==0: # It could be a pad, not a drill
                        continue
                    if pad.GetShape()!=0:
                        print('WARNING: No support for non-circular mounting holes', file=sys.stderr)
                        continue
                    ref_info['mounting_hole_radius'] = units_to_mm(ds[0])*0.5
                    #print('Mounting hole:', ref,
                    #      ' at (%s,%s)'%(fp_x, -fp_y), # show in KiCAD coords
                    #      ' size=', ref_info['mounting_hole_radius'])
                    is_mounting_hole = True
                    break
        ref_info['is_mounting_hole'] = is_mounting_hole
        ref_map[ref] = ref_info

        # remember that this footprint has this ref
        if not is_mounting_hole:
            if footprint in fp_map:
                fp_map[footprint]['refs'].append(ref)
            else:
                fp_map[footprint] = {
                    'is_th' : fp.HasThroughHolePads(),
                    'refs' : [ref],
                    'alias' : None,
                    'display_name' : None,
                    'force_smd' : False
                }
        else:
            mounting_holes[ref] = ref_info

        #print(fp.Footprint().GetName())
        #pprint(dir(fp.Footprint()))
    return ref_map, fp_map, mounting_holes

def load_3d_models(ref_list, ref_map, desc):
    temp_dir = os.path.expanduser(os.environ['TMPDIR']) if 'TMPDIR' in os.environ else None
    scriptdir = os.path.dirname(os.path.realpath(__file__))
    fnames = []
    for ref in ref_list:
        comp = ref_map[ref]
        for modinfo in comp['models']:
            model_filename = os.path.expandvars(modinfo['model'])
            fnames.append(model_filename)
    # get uniques
    fnames = list(set(fnames))
    print(f'Loading {len(fnames)} 3D models for {desc} components...')
    for ref in ref_list:
        comp = ref_map[ref]
        for modinfo in comp['models']:
            model_filename = os.path.expandvars(modinfo['model'])
            modinfo['mesh'] = mesh_ops.load_mesh(model_filename, scriptdir, temp_dir)


#
# Execution starts here
#
parser = argparse.ArgumentParser(
    description='Create jigs in a jiffy',
    epilog='Use the examples, Luke!')

group = parser.add_mutually_exclusive_group(required=True)
group.add_argument('--examples', default=False, action='store_true',
    help='''Shows examples of usage''')
group.add_argument('-i','--pcb', metavar='FILENAME',
    help='KiCAD PCB file (.kicad_pcb) to process')
group.add_argument('--footprint', metavar='SPEC',
    action='extend', nargs='+', type=str,
    help='''Generate a shell for specified kicad library footprint(s),
instead of a PCB. Use --examples for info on SPEC''')
group.add_argument('--model3d', action='extend', nargs='+', type=str,
    help='''Generate a shell from 3D model(s).''')

parser.add_argument('--pcb-footprints', action='store_true', default=False,
    help='''Generates one shell per footprint used on the PCB design
            given through --pcb.''')
parser.add_argument('--arrange', default='x', choices=['x','y'],
    help='''Arrange shells in this direction. Works with --footprint,
            --model3d and --pcb-footprints''')
parser.add_argument('--gap', metavar='DISTANCE', type=float,
    help='''Gap between shells. Applies with --arrange''')
parser.add_argument('-c', '--config', metavar='FILENAME.toml',
    help='Use this configuration options file for various parameters.')

parser.add_argument('-o','--output',
    help='Output file.')
parser.add_argument('-f', '--output-format', choices=['stl','scad'],
    help='Output file format. Default autodect based on output file extension.')
parser.add_argument('--keep-orientation',
    action='store_true',
    default=False,
    help='''Match orientation of the output to KiCAD 3D view.
The default orients the output for direct printing (i.e. rotated by 180 degrees
along the X axis.)''')
parser.add_argument('--dump-config', metavar='FILENAME.toml',
    help='''Save a copy of the effective configuration after applying
    internal defaults, user and config file.''')
parser.add_argument('--genconfig', metavar='FILENAME.toml',
    help='''Generate a default configuration file, from an
    input KiCAD PCB. This lists all footprint and components.
    User friendly openscad output can be generated, starting
    with that as the base''')

group = parser.add_mutually_exclusive_group()
group.add_argument("-v", "--verbose", help='Verbose messages')
group.add_argument("-q", "--quiet", help='Info messages are suppressed')
args = parser.parse_args()

# Validate command line parameter requirements
if args.pcb_footprints and not args.pcb:
    print(f"--pcb-footprints requires --pcb", file=sys.stderr)
    sys.exit(1)

if args.gap:
    if not (args.pcb_footprints or args.footprint or args.model3d):
        print("--gap requires at-least one of --pcb-footprints, --footprint or --model3d")
        sys.exit(1)
else:
    # FIXME - can this come from elsewhere - like a config ?
    args.gap = 10.0

if args.examples:
    print(f"Sorry, examples aren't created yet. Use the source, Luke!", file=sys.stderr)
    sys.exit(1)

if args.footprint:
    try:
        ref_map, fp_map = load_footprints(args.footprint)
    except ValueError as err:
        print(f"ERROR: {err}", file=sys.stderr)
        sys.exit(-1)
    mh_map = {}

if args.model3d:
    print(f"Sorry, the model3d option isn't implemented yet", file=sys.stderr)
    sys.exit(1)

# determine extension
if args.output and not args.output_format:
    out_split = os.path.splitext(args.output)
    out_ext = out_split[1] # will be empty string if no extension
    if out_ext in ['.stl','.scad']:
        args.output_format = out_ext[1:]
    if not args.output_format:
        print(f"Unrecorgnized extension in output filename '{args.output}'", file=sys.stderr)
        sys.exit(1)

if args.pcb:
    board = pcbnew.LoadBoard(args.pcb)
    ref_map, fp_map, mh_map = get_ref_info(board.Footprints(), args.pcb_footprints)

if args.genconfig:
    jigconfig.generate_config(args.genconfig, ref_map, fp_map)
    print(f'Generated : %{args.genconfig}')
    sys.exit(0)

jigconfig.load_user_config('jigit')

try:
    cfg, config_text, used_th_fp, th_ref_list, smd_ref_list = jigconfig.load(args.config, ref_map, fp_map, mh_map)
except ValueError as err:
    print(f"ERROR: {err}", file=sys.stderr)
    sys.exit(-1)
#pprint(cfg)

if args.pcb and args.pcb_footprints:
    # trim th_ref_list. Keep only one component per footprint
    final_ref_list = []
    for key in fp_map:
        if fp_map[key]['is_th'] and not fp_map[key]['force_smd']:
            ref_list = fp_map[key]['refs']
            retain_ref = ref_list[0]
            final_ref_list.append(retain_ref)
            # remove the rest
            for comp_ref in ref_list[1:]:
                ref_map.pop(comp_ref)
    th_ref_list = final_ref_list
    print(f"Selected {len(th_ref_list)} unique footprint(s) on the board:",
          ",".join(th_ref_list))

mounting_holes = []
for name in mh_map.keys():
    mounting_holes.append([mh_map[name]['x'], mh_map[name]['y']])

if args.dump_config:
    with open(args.dump_config, 'w') as fp:
        toml.dump(cfg, fp)

if not args.output:
    print(f"ERROR: Need an output file", file=sys.stderr)
    sys.exit(-1)

if args.pcb:
    do_pcb_proc = True if not args.pcb_footprints else False
else:
    do_pcb_proc = False

pcb_thickness = cfg['pcb']['thickness']
shell_clearance = cfg['TH']['component_shell']['shell_clearance_from_pcb']
shell_type = cfg['TH']['component_shell']['shell_type']
if shell_type in ['tight']:
    print(f"ERROR: shell_type='{shell_type}' is not implemented yet.", file=sys.stderr)
    sys.exit(-1)
shell_gap = cfg['TH']['component_shell']['shell_gap']
shell_thickness = cfg['TH']['component_shell']['shell_thickness']

arc_resolution = cfg['pcb']['tesellate_edge_cuts_curve']

base_line_width = cfg['holder']['base']['line_width']
base_line_height = cfg['holder']['base']['line_height']
pcb_perimeter_height = cfg['holder']['base']['perimeter_height']
pcb_holder_gap = cfg['holder']['pcb_gap']
pcb_holder_overlap = cfg['holder']['pcb_overlap']
pcb_holder_perimeter = cfg['holder']['perimeter']
forced_pcb_supports = cfg['holder']['forced_grooves']
groove_size = cfg['holder']['groove_size']
ref_do_not_process = cfg['TH']['refs_do_not_process']
ref_process_only_these = cfg['TH']['refs_process_only_these']
jig_type = cfg['jig']['type']
jig_type_component_fitting = (jig_type == 'component_fitting')
smd_clearance_from_shells = cfg['SMD']['clearance_from_shells']
smd_gap_from_shells = cfg['SMD']['gap_from_shells']
if jig_type_component_fitting:
    if shell_clearance>0:
        print('INFO: Generating component shells, note shell_clearance=%s will cut into shell.'
            %(shell_clearance))


# Setup environment for file name expansion
# First take from user config
for env_var_name in cfg['environment']:
    os.environ[env_var_name] = cfg['environment'][env_var_name]
if args.pcb:
    os.environ["KIPRJMOD"] = os.path.split(args.pcb)[0]
# Now add onto it, this allows overrides from user config
path_sys_3dmodels = '/usr/share/kicad/3dmodels'
for ver in ['', 6,7,8]: # Hmm - would we need more ?
    env_var_name = 'KICAD%s_3DMODEL_DIR'%(ver)
    if env_var_name not in os.environ:
        os.environ[env_var_name] = path_sys_3dmodels

load_3d_models(th_ref_list, ref_map, 'Through Hole')
load_3d_models(smd_ref_list, ref_map, 'SMD')

if args.output_format == 'stl':
    fp_scad = tempfile.NamedTemporaryFile(mode='w', suffix='.scad', delete_on_close=False)
    oscad_filename = fp_scad.name
    stl_filename = args.output
else:
    oscad_filename = args.output
    fp_scad = open(oscad_filename, 'w')

pcb_segments = []
pcb_filled_shapes = []
seg_shapes = []


if do_pcb_proc:
    edge_cuts.load(board, pcb_segments, pcb_filled_shapes)

    if not edge_cuts.coalesce_segments(pcb_segments, seg_shapes):
        print('ERROR: Please check the edge cuts layer in KiCAD.')
        print('ERROR: There are incomplete outlines. DRC or 3D View should help')
        print('ERROR: diagnose the issue')
        sys.exit(-1)

    edge_cuts.tesellate(arc_resolution, seg_shapes, pcb_filled_shapes)
    edge_cuts.compute_areas(pcb_filled_shapes)

    if len(pcb_filled_shapes) == 0:
        print('ERROR: At-least one filled shape is needed in Edge.Cuts layer')
        print('Please check and validate board file.')
        sys.exit(-1)

    # Find the largest filled area. This is assumed to be the actual
    # PCB outline
    pcb_filled_shapes.sort(key=lambda x:x['area'], reverse=True)
    # And hence these are the vertices
    pcb_edge_points = pcb_filled_shapes[0]['vertices']

all_shells = []
fp_centers = []
topmost_z = 0

# For each TH component on the board
for this_ref in th_ref_list:
    print('Processing TH :', this_ref)
    # each footprint can have multiple models.
    # each model that is "in contact" with the board will generate
    # a shell
    local_max_z = 0
    local_min_z = float('inf')
    subshells = {
        'ref' : this_ref,
        'shell' : [],
        'courtyard' : None
    }
    th = ref_map[this_ref]
    for idx, modinfo in enumerate(th['models']):
        mesh = modinfo['mesh']
        if mesh.shape[0]==0:
            print('  WARNING: Mesh %s is empty on import. Watch out for intended side effects. SKIPPING!'
                  %(modinfo['model']))
            continue
        mesh, min_z, max_z = xform_mesh(mesh, modinfo, th['orientation'])
        #print('min_z = ', min_z, ' max_z = ', max_z)
        if min_z>0:
            print('  Mesh %s is NOT mounted on board. Skipping.'%(modinfo['model']))
        else:
            min_x = min(mesh[:,0])
            max_x = max(mesh[:,0])
            min_y = min(mesh[:,1])
            max_y = max(mesh[:,1])
            center_x = ((min_x + max_x)/2)
            center_y = ((min_y + max_y)/2)
            fp_centers.append([center_x+th['x'],center_y+th['y']])
            #print('Hull size = ', len(hull.vertices), ' min Z=', min_z, ' max Z=', max_z)
            #print(hull_verts)
            shell_ident = '%s_%d'%(this_ref,idx)
            printable_threshold = cfg['3dprinter']['min_printable_hole_area']
            h_bins = compute_shells.fitting_pockets(mesh, 0.5, printable_threshold)
            for this_bin in h_bins:
                this_bin['corners'], this_bin['corner_segments'] = geom_ops.extract_corners_2D(this_bin['hull'])

            this_subshell = {
                'name':shell_ident,
                'min_z':min_z,
                'max_z':max_z,
                'model':modinfo['model'],
                'mesh' : mesh,
                'fp_center': [center_x+th['x'],center_y+th['y']],
                'fitting_bins' : h_bins
            }
            this_subshell['x'] = th['x']
            this_subshell['y'] = th['y']
            this_subshell['orientation'] = th['orientation']
            subshells['shell'].append(this_subshell)
            print('  Generating shell %s for ref %s with mesh %s'%(shell_ident, this_ref, modinfo['model']))
            local_max_z = max(local_max_z, max_z)
            local_min_z = min(local_min_z, min_z)
    if len(subshells['shell'])>1:
        all_hulls = None
        for ss in subshells['shell']:
            # first bin is the biggest one
            this_hull = ss['fitting_bins'][0]['hull']
            if all_hulls is None:
                all_hulls = np.copy(this_hull)
            else:
                all_hulls = np.concatenate((this_hull, all_hulls), axis=0)
        hull = scipy.spatial.ConvexHull(all_hulls)
        hull_verts = all_hulls[hull.vertices]
        subshells['combined_hull'] = hull_verts
    if local_max_z > 0: # Means we found a mesh
        subshells['max_z'] = local_max_z
        subshells['min_z'] = local_min_z
        subshells['front_courtyard'] = th['front_courtyard']
        all_shells.append(subshells)
    topmost_z = max(topmost_z, local_max_z)

if do_pcb_proc:
    smd_keepouts = []
    for this_ref in smd_ref_list:
        smd = ref_map[this_ref]
        #print('Processing SMD :', smd['ref'])
        # each footprint can have multiple models.
        # each model that is "in contact" with the board will generate
        # a shell
        for idx, modinfo in enumerate(smd['models']):
            mesh = modinfo['mesh']
            if mesh.shape[0]==0:
                print('  WARNING: Mesh %s is empty on import. Watch out for intended side effects. SKIPPING!'
                      %(modinfo['model']))
                continue
            mesh, min_z, max_z = xform_mesh(mesh, modinfo, smd['orientation'])
            keepout_ident = '%s_%d'%(this_ref,idx)
            smd_keepouts.append({
                'name' : keepout_ident,
                'ref' : this_ref,
                'min_z':min_z,
                'max_z':max_z,
                'model':modinfo['model'],
                'x' : smd['x'],
                'y' : smd['y'],
                'orientation' : smd['orientation'],
                'front_courtyard' : smd['front_courtyard']
            })
            topmost_z = max(topmost_z, max_z)

if do_pcb_proc:
    # Compute bounding box of PCB
    # FIXME: make this min, max code less verbose
    pcb_min_x = pcb_max_x = pcb_edge_points[0][0]
    pcb_min_y = pcb_max_y = pcb_edge_points[0][1]
    for pt in pcb_edge_points:
        pcb_min_x = min(pcb_min_x, pt[0])
        pcb_max_x = max(pcb_max_x, pt[0])
        pcb_min_y = min(pcb_min_y, pt[1])
        pcb_max_y = max(pcb_max_y, pt[1])

    pcb_bb_corners = [
        [pcb_min_x , -pcb_min_y],
        [pcb_min_x , -pcb_max_y],
        [pcb_max_x , -pcb_min_y],
        [pcb_max_x , -pcb_max_y]
    ]

    # Delaunay triangulation will be done on the following points
    # 1. centers of all considered footprints
    # 2. mounting holes
    # 3. bounding box corners of PCB edge. mounting holes are
    #    inside the PCB and don't extend all the way to the edge.
    #    If we don't include them, we may end up having a separate
    #    "delaunay island", depending on the exact PCB.
    dt_centers = fp_centers + pcb_bb_corners

    # ignore mounting holes outside PCB for mesh calculation
    for pt in mounting_holes:
        if (pt[0] > pcb_min_x) and (pt[0] < pcb_max_x) or \
           (pt[1] > pcb_min_y) and (pt[1] < pcb_max_y):
            dt_centers.append(pt)
        else:
            #print(pt, ' is out of PCB')
            pass

    mesh_line_segments = []
    if len(dt_centers)>=4:
        mesh_comment = 'delaunay triangulated mesh'
        d_verts = np.array(dt_centers)
        d_tris = scipy.spatial.Delaunay(d_verts)
        for tri in d_tris.simplices:
            # tri is a,b,c
            av = d_verts[tri[0]]
            a = [av[0], av[1]]
            bv = d_verts[tri[1]]
            b = [bv[0], bv[1]]
            cv = d_verts[tri[2]]
            c = [cv[0], cv[1]]
            mesh_line_segments.append([a,b])
            mesh_line_segments.append([b,c])
            mesh_line_segments.append([c,a])
    else:
        if len(dt_centers)>1:
            av = dt_centers[0]
            a = [av[0],av[1]]
            bv = dt_centers[1]
            b = [bv[0],bv[1]]
            mesh_line_segments.append([a,b])
        if len(dt_centers)==3:
            cv = dt_centers[2]
            c = [cv[0],cv[1]]
            mesh_line_segments.append([b,c])
            mesh_line_segments.append([c,a])

    groove_lines = edge_cuts.compute_grooves(arc_resolution, pcb_filled_shapes[0], groove_size)

if do_pcb_proc and cfg['jig']['mounting_hole_spacer_end']==0:
    #
    # Find the second highest Z, without looking at values that are
    # too close to the topmost z. Spacer will run from this Z
    # to almost the bottom of the second tallest component on the
    # board, or the second support ring of any component that comes
    # lower.
    z_second_highest = -1
    spacer_start = 0
    h2_z_name = ''
    z_list = []
    #  little margin of error, to compensate for mis-aligned bergs ?
    thresh = topmost_z - 0.2
    for subshells in all_shells:
        this_ref = subshells['ref']
        for shell_info in subshells['shell']:
            for this_bin in shell_info['fitting_bins']:
                for tmz in [ this_bin['end_z'],
                             this_bin['start_z'] ]:
                    if tmz < thresh and tmz>z_second_highest:
                        z_second_highest = tmz
                        h2_z_name = this_ref
                    elif tmz >= thresh and tmz < topmost_z:
                        spacer_start = max(spacer_start, tmz)
                        print("WARNING: you have component %s at z=%s that is being ignored as it is too close to top height %s"%(
                            this_ref, tmz, topmost_z))
                    z_list.append(tmz)
    # unique
    z_list = list(set(z_list))
    z_list.sort()
    print('Unique Zs are = ', z_list)

    mh_spacer_end = z_second_highest + \
                    cfg['3dprinter']['first_layer_height'] + \
                    cfg['3dprinter']['layer_height']
    cfg['jig']['mounting_hole_spacer_end'] = mh_spacer_end

    # one extra layer to have at-least one line show up
    spacer_start -= cfg['3dprinter']['layer_height']
    if cfg['jig']['mounting_hole_spacer_start'] == 0:
        cfg['jig']['mounting_hole_spacer_start'] = spacer_start

    print('Mounting hole spacer ends at Z=%s, component is %s'%(mh_spacer_end, h2_z_name))
    print('Mounting hole spacer start = %s, height= %s'%(spacer_start,spacer_start-mh_spacer_end))

if not cfg['jig']['mounting_hole_bolt_is_external'] and \
   not cfg['jig']['mounting_hole_spacer_is_fused']:
    print("ERROR: can't have separate spacer with internal bolt")
    sys.exit(1)

if do_pcb_proc:
    gen_scad.generate_jig(
        fp_scad,
        config_text,
        cfg,
        args.pcb,
        args.config,
        args.keep_orientation,
        all_shells,
        fp_map,
        ref_map, mh_map, smd_keepouts, topmost_z,
        pcb_edge_points,
        dt_centers,
        mesh_line_segments, groove_lines,
        pcb_min_x, pcb_max_x, pcb_min_y, pcb_max_y)

elif args.footprint or args.pcb_footprints:
    gen_scad.generate_footprints(
        fp_scad,
        config_text,
        cfg,
        args.config,
        args.keep_orientation,
        args.arrange,
        args.gap,
        all_shells,
        fp_map,
        ref_map,
        topmost_z)

# Done with the file
fp_scad.close()

if args.output_format == 'stl':
    cmd = []
    # FIXME - ideally we'll have a config in ~/.config to store things
    # like paths to binaries etc
    cfg_scad = cfg['openscad']
    cmd += [ os.path.expanduser(cfg_scad['binary']),
             '--hardwarnings' ]
    if cfg_scad['use_manifold']:
        cmd += [ '--backend', 'Manifold' ]
    cmd += [ '-o', stl_filename, oscad_filename ]
    print('Generating output using : %s'%(' '.join(cmd)))
    print('-----------------------------------------')
    retcode = subprocess.call(cmd)
    print('-----------------------------------------')
    if retcode !=0 :
        print('ERROR: OpenSCAD Failed, exit code %d'%(retcode))
    else:
        print('Done, output : %s'%(stl_filename))
else:
    print('Done, output : %s'%(oscad_filename))
#
#
# Coordinate system notes:
#
# We adhere to the normal 3D coordinate system in this program,
# with Z pointing up.
#
# KiCAD uses a coordinate system where X increases to the right,
# and Y increases down - like a regular framebuffer. Therefore,
# Y coordinates from KiCAD needs to be negated to map to the
# regular 3D system. Note that 3D meshes in KiCAD use the regular
# 3D coordinate system, so those coordinates don't need to be
# transformed.
#
# This script also uses OpenSCAD. The extrude operation extrudes
# along the positive Z axis - i.e. upwards.
#
# Z = 0 corresponds to the bottom of the PCB. At the top of the
# PCB, Z = PCB thickness
#
# This setup is so that we can exactly match KiCAD's step file
# export of the board. Overlaying the mesh generated on this
# program on top of the step file is useful both for debugging
# as well as understanding any issues.
#
# Here is the Z coordinate stackup, for top side assembly.
# Soldering is on the bottom side.
#
# Z = topmost + 1 | "base". Start of 1 mm thick layer, delaunay triangles
#     +thickness  |
#
# Z = topmost     | topmost point of tallest component, when mounted on
#     +thickness | the PCB. Typically the long end of a berg header
#
# Z = in-between  | Highest point of intermediate height component
#
# Z = thickness+  | Start of typical shell
#     clearance   | Clearance allows user to visually verify component
#                 | placement and fit from the sides
#
# Z = thickness   | PCB top
#
# Z = 0           | PCB botto
#
# This program uses this terminology
#
# edge      => closed polygon matching exact border.
#              e.g. the outer edge of the PCB. In the case of a component
#              you can think of a projection of the 3d model of
#              the component onto the Z plane, and the resulting outline.
#              outlines can be concave.
#
# hull      => convex hull of the edge. Typically used as these are
#              easier to compute and have useful properties. Using
#              concave surfaces needs more care, else things may break.
#
# overlap   => small inset of the edge/hull.
#              offset value here is called "overlap" as well.
#
# outline    => small offset of the edge/hull (meaning outwards)
#               offset value here is called "gap"
#
# perimeter => large offset of the edge/hull. Typically used to
#              build "walls" or shells
#              offset value here is termed "thickness"
#
# component/board can slide inside outline, but will abut above an
# overlap. The term "clearance" is used to a gap in the
# Z direction.
#
# "pocket" is a negative shape - e.g. the hollow cavity required
# to push in a component
#
# "shell" is a solid shape with a cavity. the cavity is a "pocket" so
# that the component can be held in the pocket.
#
#
